// File: test/EulerFinanceExploitTrap.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/EulerFinanceExploitTrap.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockDAI is ERC20 {
    constructor() ERC20("Mock DAI", "DAI") {
        _mint(msg.sender, 1000000000 * 1e18);
    }
}

contract EulerFinanceExploitTrapTest is Test {
    EulerFinanceExploitTrap public trap;
    MockDAI public dai;
    address public eulerAddress;

    function setUp() public {
        dai = new MockDAI();
        eulerAddress = address(0x1234); // Mock Euler Finance address
        trap = new EulerFinanceExploitTrap(eulerAddress, address(dai));

        // Initially, set Euler's balance above the threshold
        dai.transfer(eulerAddress, 150_000_000 * 1e18);
    }

    function testNoExploit() public {
        assertFalse(trap.isValid(), "Trap should not detect an exploit when balance is above threshold");
    }

    function testExploitDetected() public {
        // Simulate an exploit by reducing Euler's balance
        vm.prank(eulerAddress);
        dai.transfer(address(this), 60_000_000 * 1e18);

        assertTrue(trap.isValid(), "Trap should detect an exploit when balance drops below threshold");
        assertEq(trap.incident(), "Potential Euler Finance exploit detected: DAI balance dropped below threshold", "Incident message should match");
    }
}
